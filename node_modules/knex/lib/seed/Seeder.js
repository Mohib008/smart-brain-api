// Seeder
// -------

const path = require('path');
<<<<<<< HEAD
const extend = require('lodash/extend');
const includes = require('lodash/includes');
const { readdir, ensureDirectoryExists } = require('../util/fs');
const { writeJsFileUsingTemplate } = require('../util/template');

=======
const flatten = require('lodash/flatten');
const extend = require('lodash/extend');
const includes = require('lodash/includes');
const {
  ensureDirectoryExists,
  getFilepathsInFolderRecursively,
} = require('../util/fs');
const { writeJsFileUsingTemplate } = require('../util/template');

const filterByLoadExtensions = (extensions) => (value) => {
  const extension = path.extname(value);
  return includes(extensions, extension);
};

>>>>>>> 5b4323e725452769c50bfd7d5a067e1ba28ff3cd
// The new seeds we're performing, typically called from the `knex.seed`
// interface on the main `knex` object. Passes the `knex` instance performing
// the seeds.
class Seeder {
  constructor(knex) {
    this.knex = knex;
    this.config = this.setConfig(knex.client.config.seeds);
  }

  // Runs seed files for the given environment.
  async run(config) {
    this.config = this.setConfig(config);
    const all = await this._listAll();
    const files =
      config && config.specific
<<<<<<< HEAD
        ? all.filter((file) => file === config.specific)
=======
        ? all.filter((file) => path.basename(file) === config.specific)
>>>>>>> 5b4323e725452769c50bfd7d5a067e1ba28ff3cd
        : all;
    return this._runSeeds(files);
  }

  // Creates a new seed file, with a given name.
  async make(name, config) {
    this.config = this.setConfig(config);
    if (!name)
      throw new Error('A name must be specified for the generated seed');
    await this._ensureFolder(config);
    const seedPath = await this._writeNewSeed(name);
    return seedPath;
  }

  // Lists all available seed files as a sorted array.
  async _listAll(config) {
    this.config = this.setConfig(config);
    const loadExtensions = this.config.loadExtensions;
<<<<<<< HEAD
    return readdir(this._absoluteConfigDir()).then((seeds) =>
      seeds
        .filter((value) => {
          const extension = path.extname(value);
          return includes(loadExtensions, extension);
        })
        .sort()
    );
=======
    const seeds = flatten(
      await Promise.all(
        this._absoluteConfigDirs().map(getFilepathsInFolderRecursively)
      )
    );
    // if true, each dir are already sorted
    // (getFilepathsInFolderRecursively does this)
    // if false, we need to sort all the seeds
    if (this.config.sortDirsSeparately) {
      return seeds.filter(filterByLoadExtensions(loadExtensions));
    } else {
      return seeds.filter(filterByLoadExtensions(loadExtensions)).sort();
    }
>>>>>>> 5b4323e725452769c50bfd7d5a067e1ba28ff3cd
  }

  // Ensures a folder for the seeds exist, dependent on the
  // seed config settings.
<<<<<<< HEAD
  async _ensureFolder() {
    const dir = this._absoluteConfigDir();

    await ensureDirectoryExists(dir);
=======
  _ensureFolder() {
    const dirs = this._absoluteConfigDirs();
    const promises = dirs.map(ensureDirectoryExists);
    return Promise.all(promises);
>>>>>>> 5b4323e725452769c50bfd7d5a067e1ba28ff3cd
  }

  // Run seed files, in sequence.
  _runSeeds(seeds) {
    seeds.forEach((seed) => this._validateSeedStructure(seed));
    return this._waterfallBatch(seeds);
  }

  // Validates seed files by requiring and checking for a `seed` function.
<<<<<<< HEAD
  _validateSeedStructure(name) {
    const seed = require(path.join(this._absoluteConfigDir(), name));
    if (typeof seed.seed !== 'function') {
      throw new Error(`Invalid seed file: ${name} must have a seed function`);
    }
    return name;
=======
  _validateSeedStructure(filepath) {
    const seed = require(filepath);
    if (typeof seed.seed !== 'function') {
      throw new Error(
        `Invalid seed file: ${filepath} must have a seed function`
      );
    }
    return filepath;
>>>>>>> 5b4323e725452769c50bfd7d5a067e1ba28ff3cd
  }

  _getStubPath() {
    return (
      this.config.stub ||
      path.join(__dirname, 'stub', this.config.extension + '.stub')
    );
  }

  _getNewStubFileName(name) {
    if (name[0] === '-') name = name.slice(1);
    return name + '.' + this.config.extension;
  }

  _getNewStubFilePath(name) {
<<<<<<< HEAD
    return path.join(this._absoluteConfigDir(), this._getNewStubFileName(name));
=======
    const fileName = this._getNewStubFileName(name);
    const dirs = this._absoluteConfigDirs();
    const dir = dirs.slice(-1)[0]; // Get last specified directory
    return path.join(dir, fileName);
>>>>>>> 5b4323e725452769c50bfd7d5a067e1ba28ff3cd
  }

  // Write a new seed to disk, using the config and generated filename,
  // passing any `variables` given in the config to the template.
  async _writeNewSeed(name) {
    const seedPath = this._getNewStubFilePath(name);
    await writeJsFileUsingTemplate(
      seedPath,
      this._getStubPath(),
      { variable: 'd' },
      this.config.variables || {}
    );
    return seedPath;
  }

  // Runs a batch of seed files.
  async _waterfallBatch(seeds) {
    const { knex } = this;
<<<<<<< HEAD
    const seedDirectory = this._absoluteConfigDir();
    const log = [];
    for (const seedName of seeds) {
      const seedPath = path.join(seedDirectory, seedName);
=======
    const log = [];
    for (const seedPath of seeds) {
>>>>>>> 5b4323e725452769c50bfd7d5a067e1ba28ff3cd
      const seed = require(seedPath);
      try {
        await seed.seed(knex);
        log.push(seedPath);
      } catch (originalError) {
        const error = new Error(
          `Error while executing "${seedPath}" seed: ${originalError.message}`
        );
        error.original = originalError;
        error.stack =
          error.stack.split('\n').slice(0, 2).join('\n') +
          '\n' +
          originalError.stack;
        throw error;
      }
    }
    return [log];
  }

<<<<<<< HEAD
  _absoluteConfigDir() {
    return path.resolve(process.cwd(), this.config.directory);
=======
  /**
   * Return all the config directories
   * @returns {string[]}
   */
  _absoluteConfigDirs() {
    const directories = Array.isArray(this.config.directory)
      ? this.config.directory
      : [this.config.directory];
    return directories.map((directory) => {
      if (!directory) {
        // eslint-disable-next-line no-console
        console.warn(
          'Failed to resolve config file, knex cannot determine where to run or make seeds'
        );
      }
      return path.resolve(process.cwd(), directory);
    });
>>>>>>> 5b4323e725452769c50bfd7d5a067e1ba28ff3cd
  }

  setConfig(config) {
    return extend(
      {
        extension: 'js',
        directory: './seeds',
        loadExtensions: [
          '.co',
          '.coffee',
          '.eg',
          '.iced',
          '.js',
          '.litcoffee',
          '.ls',
          '.ts',
        ],
<<<<<<< HEAD
=======
        sortDirsSeparately: false,
>>>>>>> 5b4323e725452769c50bfd7d5a067e1ba28ff3cd
      },
      this.config || {},
      config
    );
  }
}

module.exports = Seeder;
